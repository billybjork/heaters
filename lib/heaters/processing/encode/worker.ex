defmodule Heaters.Processing.Encode.Worker do
  @moduledoc """
  Worker for encoding source videos into master and proxy files.

  This worker handles the "downloaded â†’ encoded" stage of the video processing pipeline.
  It creates two video files from the source video:
  1. Master (lossless MKV + FFV1) for archival storage
  2. Proxy (all-I-frame H.264) for efficient seeking in the review UI and export

  ## Workflow

  1. Transition source video to :encoding state
  2. Run native encoding to create master and proxy
  3. Extract keyframe offsets for efficient seeking
  4. Upload both files to S3 (cold storage for master, hot for proxy) or temp cache
  5. Update source video with file paths and keyframe data

  ## State Management

  - **Input**: Source videos in :downloaded state without proxy_filepath
  - **Output**: Source videos with proxy_filepath, master_filepath, and keyframe_offsets
  - **Error Handling**: Marks source video as :encoding_failed on errors
  - **Idempotency**: Skip if proxy_filepath IS NOT NULL (encoding already complete)

  ## Architecture

  - **Encoding**: Native Elixir/FFmpex via Encode.Core
  - **State Management**: Elixir state transitions and database operations
  - **Storage**: S3 for both master and proxy files
  """

  use Heaters.Pipeline.WorkerBehavior,
    queue: :media_processing,
    unique: [period: 300, fields: [:args], keys: [:source_video_id]]

  alias Heaters.Media.{Video, Videos}
  alias Heaters.Pipeline.Config, as: PipelineConfig
  alias Heaters.Pipeline.WorkerBehavior
  alias Heaters.Processing.Encode.Core, as: EncodeCore
  alias Heaters.Processing.Encode.StateManager
  alias Heaters.Processing.Support.FFmpeg.Config, as: FFmpegConfig
  alias Heaters.Processing.Support.ResultBuilder
  alias Heaters.Processing.Support.Types.EncodeResult
  alias Heaters.Storage.PipelineCache.TempCache
  alias Heaters.Storage.S3.Paths, as: S3Paths
  require Logger

  @impl WorkerBehavior
  def handle_work(args) do
    handle_encoding_work(args)
  end

  defp handle_encoding_work(%{"source_video_id" => source_video_id}) do
    Logger.info("EncodeWorker: Starting encoding for source_video_id: #{source_video_id}")

    case Videos.get_source_video(source_video_id) do
      {:ok, source_video} ->
        handle_encoding(source_video)

      {:error, :not_found} ->
        WorkerBehavior.handle_not_found("Source video", source_video_id)
    end
  end

  defp handle_encoding(%Video{} = source_video) do
    # IDEMPOTENCY: Skip if proxy_filepath IS NOT NULL (encoding already complete)
    case source_video.proxy_filepath do
      nil ->
        Logger.info("EncodeWorker: Starting encoding for video #{source_video.id}")
        run_encoding_task(source_video)

      _proxy_path ->
        Logger.info("EncodeWorker: Video #{source_video.id} already encoded, skipping")

        # Return structured result for completed encoding
        ResultBuilder.encode_success(source_video.id, source_video.proxy_filepath, %{
          master_filepath: source_video.master_filepath,
          keyframe_count: length(source_video.keyframe_offsets || []),
          optimization_stats: %{
            already_processed: true
          }
        })
    end
  end

  defp run_encoding_task(source_video) do
    Logger.info("EncodeWorker: Running native encoding for source_video_id: #{source_video.id}")

    # Transition to encoding state
    case StateManager.start_encoding(source_video.id) do
      {:ok, updated_video} ->
        execute_encoding(updated_video)

      {:error, reason} ->
        Logger.error("EncodeWorker: Failed to start encoding: #{inspect(reason)}")
        {:error, reason}
    end
  end

  defp execute_encoding(source_video) do
    # Check if master generation should be skipped for cost optimization
    skip_master = FFmpegConfig.should_skip_master?([], source_video)

    # Get FFmpeg configuration
    master_args = FFmpegConfig.get_args(:master, skip_master: skip_master)
    proxy_args = FFmpegConfig.get_args(:proxy)

    # Try to get source video from temp cache first, fallback to S3
    source_path_result =
      TempCache.get_or_download(
        source_video.filepath,
        operation_name: "EncodeWorker"
      )

    case source_path_result do
      {:ok, local_source_path, cache_status} ->
        Logger.info("EncodeWorker: Using #{cache_status} source file: #{local_source_path}")

        # Check if we can reuse the normalized download as proxy (smart reuse)
        can_reuse_as_proxy = can_reuse_normalized_as_proxy?(source_video, local_source_path)

        # Generate S3 paths using centralized path service
        paths = S3Paths.generate_video_paths(source_video.id, source_video.title)

        encode_args = %{
          source_video_id: source_video.id,
          # Use local path instead of S3 path
          source_video_path: local_source_path,
          video_title: source_video.title,
          # S3 paths generated by Elixir
          master_output_path: paths.master,
          proxy_output_path: paths.proxy,
          master_args: master_args,
          proxy_args: proxy_args,
          skip_master: skip_master,
          # Temp cache for downstream stages
          use_temp_cache: true,
          # Skip proxy encoding if possible
          reuse_as_proxy: can_reuse_as_proxy
        }

        run_native_encoding(source_video, encode_args)

      {:error, reason} ->
        Logger.error("EncodeWorker: Failed to get source video: #{inspect(reason)}")
        {:error, "Failed to get source video: #{inspect(reason)}"}
    end
  end

  defp run_native_encoding(source_video, encode_args) do
    Logger.info(
      "EncodeWorker: Running native Elixir encoding with source_video_id: #{source_video.id}"
    )

    master_filepath = Map.get(encode_args, :master_output_path)
    proxy_filepath = Map.get(encode_args, :proxy_output_path)
    use_temp_cache = Map.get(encode_args, :use_temp_cache, false)

    case EncodeCore.process_source_video(
           Map.get(encode_args, :source_video_path),
           source_video.id,
           source_video.title || "Video #{source_video.id}",
           master_filepath,
           proxy_filepath,
           operation_name: "EncodeWorker",
           use_temp_cache: use_temp_cache
         ) do
      {:ok, result} ->
        Logger.info("EncodeWorker: Native Elixir encoding completed successfully")

        if use_temp_cache do
          process_native_temp_cache_results(source_video, result, encode_args)
        else
          process_native_encoding_results(source_video, result)
        end

      {:error, reason} ->
        Logger.error("EncodeWorker: Native encoding failed: #{reason}")

        case StateManager.mark_encoding_failed(source_video.id, reason) do
          {:ok, _} ->
            {:error, reason}

          {:error, db_error} ->
            Logger.error("EncodeWorker: Failed to mark video as failed: #{inspect(db_error)}")
            {:error, reason}
        end
    end
  end

  # Check if normalized download output can be reused as proxy
  defp can_reuse_normalized_as_proxy?(_source_video, local_source_path) do
    if local_source_path != "" do
      case analyze_video_for_proxy_reuse(local_source_path) do
        {:ok, analysis} ->
          analysis.video_codec == "h264" &&
            analysis.audio_codec == "aac" &&
            analysis.height <= 1080 &&
            analysis.width <= 1920 &&
            reasonable_quality?(analysis)

        {:error, reason} ->
          Logger.debug("EncodeWorker: Cannot analyze for proxy reuse: #{inspect(reason)}")
          false
      end
    else
      false
    end
  end

  # Analyze video file to determine if it's suitable for proxy reuse
  defp analyze_video_for_proxy_reuse(video_path) do
    cmd = [
      "ffprobe",
      "-v",
      "quiet",
      "-print_format",
      "json",
      "-show_streams",
      "-show_format",
      video_path
    ]

    case System.cmd("ffprobe", tl(cmd), stderr_to_stdout: true) do
      {output, 0} ->
        case Jason.decode(output) do
          {:ok, data} ->
            video_stream = Enum.find(data["streams"], &(&1["codec_type"] == "video"))
            audio_stream = Enum.find(data["streams"], &(&1["codec_type"] == "audio"))

            analysis = %{
              video_codec: video_stream["codec_name"],
              audio_codec: audio_stream && audio_stream["codec_name"],
              width: video_stream["width"],
              height: video_stream["height"],
              bitrate: String.to_integer(data["format"]["bit_rate"] || "0"),
              duration: String.to_float(data["format"]["duration"] || "0.0")
            }

            {:ok, analysis}

          {:error, reason} ->
            {:error, "JSON decode failed: #{inspect(reason)}"}
        end

      {error, _code} ->
        {:error, "ffprobe failed: #{error}"}
    end
  rescue
    error ->
      {:error, "Analysis exception: #{Exception.message(error)}"}
  end

  # Check if video quality is reasonable for proxy use
  defp reasonable_quality?(analysis) do
    analysis.bitrate > 500_000 && analysis.duration > 0
  end

  # Native Elixir result processing functions
  defp process_native_encoding_results(source_video, %EncodeResult{} = result) do
    proxy_filepath = result.proxy_filepath
    master_filepath = result.master_filepath
    keyframe_count = result.keyframe_count
    encoding_metrics = result.encoding_metrics
    metadata = result.metadata || %{}

    Logger.info("EncodeWorker: Processing native encoding results for #{source_video.id}")
    Logger.info("EncodeWorker: Proxy: #{proxy_filepath}, Master: #{master_filepath}")

    update_attrs = %{
      proxy_filepath: proxy_filepath,
      master_filepath: master_filepath,
      ingest_state: :encoded,
      keyframe_offsets: []
    }

    case StateManager.complete_encoding(source_video.id, update_attrs) do
      {:ok, updated_video} ->
        Logger.info("EncodeWorker: Native encoding completed for video #{updated_video.id}")
        :ok = PipelineConfig.maybe_chain_next_job(__MODULE__, updated_video)
        Logger.info("EncodeWorker: Successfully chained to next pipeline stage")

        ResultBuilder.encode_success(
          source_video.id,
          proxy_filepath,
          %{
            master_filepath: master_filepath,
            keyframe_count: keyframe_count,
            encoding_metrics: encoding_metrics,
            metadata: metadata,
            duration_ms: result.duration_ms
          }
        )

      {:error, reason} ->
        Logger.error(
          "EncodeWorker: Failed to update video #{source_video.id}: #{inspect(reason)}"
        )

        {:error, reason}
    end
  end

  defp process_native_temp_cache_results(source_video, %EncodeResult{} = result, _encode_args) do
    local_proxy_path = result.optimization_stats[:proxy_local_path]
    local_master_path = result.optimization_stats[:master_local_path]

    Logger.info("EncodeWorker: Processing native temp cache results for #{source_video.id}")

    Logger.info(
      "EncodeWorker: Local proxy: #{local_proxy_path}, Local master: #{local_master_path}"
    )

    temp_results =
      %{}
      |> maybe_put_if_valid("proxy", local_proxy_path)
      |> maybe_put_if_valid("master", local_master_path)

    case TempCache.put_processing_results(temp_results, source_video.id) do
      {:ok, _cached_results} ->
        Logger.info("EncodeWorker: Temp cache files stored for video #{source_video.id}")

        paths = S3Paths.generate_video_paths(source_video.id, source_video.title)

        update_attrs = %{
          proxy_filepath: paths.proxy,
          master_filepath: paths.master,
          ingest_state: :encoded,
          keyframe_offsets: result.metadata[:keyframe_offsets] || []
        }

        case StateManager.complete_encoding(source_video.id, update_attrs) do
          {:ok, updated_video} ->
            Logger.info(
              "EncodeWorker: Native temp cache encoding completed for video #{updated_video.id}"
            )

            :ok = PipelineConfig.maybe_chain_next_job(__MODULE__, updated_video)
            Logger.info("EncodeWorker: Successfully chained to next pipeline stage")

            ResultBuilder.encode_success(
              source_video.id,
              paths.proxy,
              %{
                master_filepath: paths.master,
                keyframe_count: result.keyframe_count,
                encoding_metrics: result.encoding_metrics,
                metadata: result.metadata,
                duration_ms: result.duration_ms
              }
            )

          {:error, reason} ->
            Logger.error(
              "EncodeWorker: Failed to update video #{source_video.id}: #{inspect(reason)}"
            )

            {:error, reason}
        end

      {:error, reason} ->
        Logger.error("EncodeWorker: Failed to store temp cache files: #{inspect(reason)}")
        {:error, reason}
    end
  end

  # Helper function to only include valid file paths in temp cache results
  defp maybe_put_if_valid(map, _key, nil), do: map
  defp maybe_put_if_valid(map, _key, ""), do: map

  defp maybe_put_if_valid(map, key, path) when is_binary(path) do
    if File.exists?(path) do
      Map.put(map, key, path)
    else
      map
    end
  end

  defp maybe_put_if_valid(map, _key, _invalid), do: map
end
