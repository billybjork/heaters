defmodule Heaters.Processing.Encode.Core do
  @moduledoc """
  Native Elixir implementation of media encoding functionality.

  This module provides the main interface for video encoding operations,
  delegating to focused sub-modules for specific concerns:

  - `FileOperations` - File and directory management
  - `MetadataExtraction` - Video metadata and keyframe extraction  
  - `VideoProcessing` - Proxy and master file creation
  - `OutputHandling` - Upload vs cache strategies

  This module handles:
  - Master file creation (lossless archival)
  - Proxy file creation (all I-frame for review)
  - Keyframe offset extraction
  - Video metadata extraction
  - Smart reuse optimization
  - Progress reporting and temp cache management

  Uses existing infrastructure:
  - `Heaters.Processing.Support.FFmpeg.Runner` for video operations
  - `Heaters.Processing.Support.FFmpeg.Config` for encoding profiles
  - `Heaters.Storage.S3.Core` for S3 operations
  - `Heaters.Processing.Support.Types` for structured results
  """

  require Logger

  alias Heaters.Processing.Support.Types.EncodeResult

  alias Heaters.Processing.Encode.{
    FileOperations,
    MetadataExtraction,
    OutputHandling,
    VideoProcessing
  }

  @type encode_result :: {:ok, EncodeResult.t()} | {:error, String.t()}
  @type encode_opts :: [
          operation_name: String.t(),
          temp_dir: String.t() | nil,
          use_temp_cache: boolean(),
          skip_master: boolean(),
          reuse_as_proxy: boolean(),
          master_profile: atom(),
          proxy_profile: atom()
        ]

  @doc """
  Process a source video into master and proxy formats using native Elixir implementation.

  ## Parameters
  - `source_video_path`: Local or S3 path to source video
  - `source_video_id`: Database ID of the source video
  - `video_title`: Video title for logging and metadata
  - `master_output_path`: S3 path for master output (generated by Elixir)
  - `proxy_output_path`: S3 path for proxy output (generated by Elixir)
  - `opts`: Processing options
    - `:operation_name`: Name for logging (defaults to "Encode")
    - `:temp_dir`: Custom temporary directory
    - `:use_temp_cache`: If true, cache files locally instead of uploading immediately
    - `:skip_master`: Skip master file generation for cost optimization
    - `:reuse_as_proxy`: Try to reuse source as proxy if compatible
    - `:master_profile`: FFmpeg profile for master encoding (defaults to :master)
    - `:proxy_profile`: FFmpeg profile for proxy encoding (defaults to :proxy)

  ## Returns
  - `{:ok, encode_result}` with processing results and metadata
  - `{:error, reason}` on failure
  """
  @spec process_source_video(
          String.t(),
          integer(),
          String.t(),
          String.t(),
          String.t(),
          encode_opts()
        ) ::
          encode_result()
  def process_source_video(
        source_video_path,
        source_video_id,
        video_title,
        master_output_path,
        proxy_output_path,
        opts \\ []
      ) do
    operation_name = Keyword.get(opts, :operation_name, "Encode")
    use_temp_cache = Keyword.get(opts, :use_temp_cache, false)
    skip_master = Keyword.get(opts, :skip_master, false)
    reuse_as_proxy = Keyword.get(opts, :reuse_as_proxy, false)
    master_profile = Keyword.get(opts, :master_profile, :master)
    proxy_profile = Keyword.get(opts, :proxy_profile, :proxy)

    Logger.info(
      "#{operation_name}: Starting native Elixir encoding for video #{source_video_id}: #{video_title}"
    )

    Logger.info("#{operation_name}: Source: #{source_video_path}")

    Logger.info(
      "#{operation_name}: Master profile: #{master_profile}, Proxy profile: #{proxy_profile}"
    )

    with {:ok, work_dir} <-
           FileOperations.setup_temp_directory(Keyword.get(opts, :temp_dir), operation_name),
         {:ok, local_source_path} <-
           FileOperations.get_local_source_video(source_video_path, work_dir, operation_name),
         {:ok, source_metadata} <-
           MetadataExtraction.extract_source_metadata(local_source_path, operation_name),
         {:ok, proxy_info} <-
           VideoProcessing.create_proxy_file(
             local_source_path,
             proxy_output_path,
             source_metadata,
             proxy_profile,
             reuse_as_proxy,
             work_dir,
             operation_name
           ),
         {:ok, master_info} <-
           VideoProcessing.create_master_file(
             local_source_path,
             master_output_path,
             source_metadata,
             master_profile,
             skip_master,
             work_dir,
             operation_name
           ),
         {:ok, final_result} <-
           OutputHandling.handle_output_strategy(
             proxy_info,
             master_info,
             source_metadata,
             use_temp_cache,
             operation_name
           ) do
      result =
        EncodeResult.new(
          source_video_id: source_video_id,
          proxy_filepath: final_result[:proxy_path] || proxy_output_path,
          master_filepath: final_result[:master_path] || master_info[:s3_path],
          keyframe_count: length(proxy_info[:keyframe_offsets] || []),
          optimization_stats: %{
            reused_as_proxy: reuse_as_proxy,
            skipped_master: skip_master,
            used_temp_cache: use_temp_cache,
            proxy_local_path: final_result[:proxy_local_path],
            master_local_path: final_result[:master_local_path]
          },
          encoding_metrics: %{
            master_profile: master_profile,
            proxy_profile: proxy_profile,
            source_metadata: source_metadata
          },
          metadata: final_result
        )

      Logger.info("#{operation_name}: Encoding completed successfully using native Elixir")
      {:ok, result}
    else
      {:error, reason} ->
        Logger.error("#{operation_name}: Encoding failed for video #{source_video_id}: #{reason}")

        {:error, reason}
    end
  end

  @doc """
  Create a proxy video file using FFmpeg with all I-frame encoding.

  This function handles the proxy creation process including smart reuse
  when the source video is already suitable as a proxy.

  Delegates to VideoProcessing.create_proxy_file/7.
  """
  @spec create_proxy_file(
          String.t(),
          String.t(),
          map(),
          atom(),
          boolean(),
          String.t(),
          String.t()
        ) ::
          {:ok, map()} | {:error, String.t()}
  def create_proxy_file(
        source_path,
        output_s3_path,
        metadata,
        profile,
        reuse_source,
        work_dir,
        operation_name
      ) do
    VideoProcessing.create_proxy_file(
      source_path,
      output_s3_path,
      metadata,
      profile,
      reuse_source,
      work_dir,
      operation_name
    )
  end

  @doc """
  Create a master video file using FFmpeg with lossless encoding.

  Creates an archival-quality master file for long-term storage.

  Delegates to VideoProcessing.create_master_file/7.
  """
  @spec create_master_file(
          String.t(),
          String.t(),
          map(),
          atom(),
          boolean(),
          String.t(),
          String.t()
        ) ::
          {:ok, map()} | {:error, String.t()}
  def create_master_file(
        source_path,
        output_s3_path,
        metadata,
        profile,
        skip_creation,
        work_dir,
        operation_name
      ) do
    VideoProcessing.create_master_file(
      source_path,
      output_s3_path,
      metadata,
      profile,
      skip_creation,
      work_dir,
      operation_name
    )
  end
end
