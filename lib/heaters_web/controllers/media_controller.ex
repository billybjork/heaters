defmodule HeatersWeb.MediaController do
  @moduledoc """
  Controller for all media-related operations in the Heaters application.

  This controller consolidates video submission and streaming functionality, providing
  a unified interface for all media operations including:

  ## Video Submission

  - Video URL submission for processing pipeline
  - Integration with background job queue (Oban)
  - Flash message handling and redirects

  ## Virtual Clip Streaming

  - Virtual clip streaming with embedded timing metadata
  - CORS-safe proxy for CloudFront video streaming
  - HTTP Range request support for frame-accurate navigation

  ## Architecture

  The controller combines two previously separate controllers:
  - Video submission (from VideoController) 
  - Virtual clip streaming (from VirtualClipController)

  This consolidation improves maintainability while keeping related media operations
  co-located in a single module.
  """

  use HeatersWeb, :controller
  require Logger
  alias Heaters.Media.Videos

  ## Video Submission

  @doc """
  Submit a video URL for processing.

  Accepts video URLs and submits them to the processing pipeline via the Videos context.
  On success, redirects back to the referring page with a success flash message.
  On failure, redirects back with an error flash message.

  ## Parameters

  - `url` - Video URL to submit for processing

  ## Response

  Redirects to the referring page with appropriate flash message.
  """
  def create(conn, %{"url" => url}) do
    case Videos.submit(url) do
      :ok ->
        conn
        |> put_flash(:info, "Submitted!")
        |> redirect(to: get_referrer(conn))

      {:error, msg} ->
        conn
        |> put_flash(:error, msg)
        |> redirect(to: get_referrer(conn))
    end
  end

  ## Temp File Serving

  @doc """
  Serve temporary clip files with HTTP Range support for frame navigation.

  Serves temporary clip files generated by FFmpeg with proper HTTP 206 responses
  for frame-accurate video seeking. Only serves in development mode for security.

  ## Parameters

  - `filename` - Temporary file name (must end with .mp4)

  ## Response

  Returns video file with proper range support:
  - HTTP 206 Partial Content responses for seeking
  - Accept-Ranges and Content-Range headers
  - Cache-Control headers to prevent browser caching
  - CORS headers for cross-origin requests

  ## Security

  - Only serves in development mode
  - Only serves .mp4 files
  - Files must exist in system temp directory
  - Uses clip_ prefix pattern matching for security
  """
  def serve_temp_file(conn, %{"filename" => filename}) do
    # Only serve in development mode and only .mp4 files for security
    if Application.get_env(:heaters, :app_env, "production") == "development" and
         String.ends_with?(filename, ".mp4") do
      temp_path = Path.join(System.tmp_dir!(), filename)

      if File.exists?(temp_path) do
        serve_temp_file_with_ranges(conn, temp_path, filename)
      else
        conn
        |> put_status(404)
        |> json(%{error: "File not found"})
      end
    else
      conn
      |> put_status(404)
      |> json(%{error: "Not found"})
    end
  end

  ## Private Implementation

  # Serve temp file with proper HTTP range support for video seeking
  # CRITICAL: 206 Partial Content responses required for frame navigation
  defp serve_temp_file_with_ranges(conn, file_path, filename) do
    {:ok, %File.Stat{size: file_size}} = File.stat(file_path)

    # Get file modification time for cache busting
    file_stat = File.stat!(file_path)

    mtime_unix =
      file_stat.mtime |> :calendar.datetime_to_gregorian_seconds() |> Integer.to_string()

    etag = :crypto.hash(:md5, "#{filename}-#{mtime_unix}") |> Base.encode16(case: :lower)

    conn =
      conn
      |> put_resp_content_type("video/mp4")
      |> put_resp_header("content-disposition", "inline")
      |> put_resp_header("accept-ranges", "bytes")
      |> put_resp_header("cache-control", "no-cache, no-store, must-revalidate")
      |> put_resp_header("pragma", "no-cache")
      |> put_resp_header("etag", etag)

    case get_req_header(conn, "range") do
      ["bytes=" <> spec] ->
        handle_range_request(conn, spec, file_path, file_size)

      _ ->
        # No range header - serve whole file
        conn
        |> put_resp_header("content-length", Integer.to_string(file_size))
        |> send_file_or_head(200, file_path)
    end
  end

  defp handle_range_request(conn, spec, file_path, file_size) do
    case parse_range_spec(spec, file_size) do
      {:ok, {start_pos, end_pos}} ->
        length = end_pos - start_pos + 1

        conn
        |> put_resp_header("content-range", "bytes #{start_pos}-#{end_pos}/#{file_size}")
        |> put_resp_header("content-length", Integer.to_string(length))
        |> send_partial_file_or_head(file_path, start_pos, length)

      :error ->
        # Invalid range - return 416 Range Not Satisfiable
        conn
        |> put_resp_header("content-range", "bytes */#{file_size}")
        |> send_resp(416, "Range Not Satisfiable")
    end
  end

  defp send_file_or_head(%{method: "HEAD"} = conn, status, _file_path) do
    send_resp(conn, status, "")
  end

  defp send_file_or_head(conn, status, file_path) do
    send_file(conn, status, file_path)
  end

  defp send_partial_file_or_head(%{method: "HEAD"} = conn, _file_path, _offset, _length) do
    send_resp(conn, 206, "")
  end

  defp send_partial_file_or_head(conn, file_path, offset, length) do
    Plug.Conn.send_file(conn, 206, file_path, offset, length)
  end

  # Parse HTTP Range header specifications
  # Supports: "N-M", "N-", "-SUFFIX"
  defp parse_range_spec(spec, file_size) do
    first_range = spec |> String.split(",", parts: 2) |> hd()

    case String.split(first_range, "-", parts: 2) do
      [start_part, end_part] -> parse_range_parts(start_part, end_part, file_size)
      _ -> :error
    end
  end

  # Format: "N-M" (specific range)
  defp parse_range_parts(start_part, end_part, file_size)
       when start_part != "" and end_part != "" do
    parse_specific_range(start_part, end_part, file_size)
  end

  # Format: "N-" (from N to end)
  defp parse_range_parts(start_part, "", file_size) when start_part != "" do
    parse_from_start_range(start_part, file_size)
  end

  # Format: "-SUFFIX" (last SUFFIX bytes)
  defp parse_range_parts("", end_part, file_size) when end_part != "" do
    parse_suffix_range(end_part, file_size)
  end

  defp parse_range_parts(_, _, _), do: :error

  defp parse_specific_range(start_part, end_part, file_size) do
    with {start_pos, ""} <- Integer.parse(start_part),
         {end_pos, ""} <- Integer.parse(end_part),
         true <- valid_specific_range?(start_pos, end_pos, file_size) do
      {:ok, {start_pos, end_pos}}
    else
      _ -> :error
    end
  end

  defp valid_specific_range?(start_pos, end_pos, file_size) do
    start_pos >= 0 and end_pos >= start_pos and end_pos < file_size
  end

  defp parse_from_start_range(start_part, file_size) do
    with {start_pos, ""} <- Integer.parse(start_part),
         true <- start_pos >= 0 and start_pos < file_size do
      {:ok, {start_pos, file_size - 1}}
    else
      _ -> :error
    end
  end

  defp parse_suffix_range(end_part, file_size) do
    with {suffix_bytes, ""} <- Integer.parse(end_part),
         true <- suffix_bytes > 0 do
      {:ok, {max(file_size - suffix_bytes, 0), file_size - 1}}
    else
      _ -> :error
    end
  end

  # Extract only the path (and query string, if any) from the Referer header.
  defp get_referrer(conn) do
    conn
    |> get_req_header("referer")
    |> List.first()
    |> case do
      nil ->
        ~p"/"

      ref ->
        %URI{path: path, query: q} = URI.parse(ref)
        if q, do: path <> "?" <> q, else: path
    end
  end
end
